#!/usr/bin/env zx

import { compile } from "json-schema-to-typescript";
import $RefParser from "@apidevtools/json-schema-ref-parser";
import { glob } from "glob";
import { mkdir, rm, writeFile } from "node:fs/promises";
import { basename, join } from "node:path";
import { $ } from "zx";
import { readFile } from "node:fs/promises";
import {} from "tsdown";

function injectBigint(schema: any): void {
  if (!schema || typeof schema !== "object") return;

  const t = schema.type;
  const isInteger =
    t === "integer" || (Array.isArray(t) && t.includes("integer"));
  if (isInteger && !schema.tsType) {
    schema.tsType = "bigint";
  }

  const keys = [
    "properties",
    "patternProperties",
    "additionalProperties",
    "items",
    "oneOf",
    "anyOf",
    "allOf",
    "$defs",
    "definitions",
  ];

  for (const k of keys) {
    const child = schema[k];
    if (!child) continue;

    if (Array.isArray(child)) {
      for (const s of child) injectBigint(s);
    } else if (typeof child === "object") {
      if (k === "items" && Array.isArray(child)) {
        for (const it of child) injectBigint(it);
      } else {
        for (const name of Object.keys(child)) {
          injectBigint(child[name]);
        }
      }
    }
  }
}

const journalEntryPoints = await glob("schema/schemas/*/*.json");

console.log("clean up output directory");

const generatedRoot = join(process.cwd(), "src", "generated");

await rm(generatedRoot, {
  recursive: true,
  force: true,
});
await mkdir(generatedRoot, { recursive: true });

const header = `/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */`;
const mainIndexFile: string[] = [header];

const biEventsFile: string[] = [header];
const simpleEventsFile: string[] = [header];

const eventNames: string[] = [];

for (const schemaPath of journalEntryPoints) {
  if (basename(join(schemaPath, "..")) === "common") {
    continue;
  }
  // We first use @apidevtools/json-schema-ref-parser to inline any external refs.
  // json-schema-to-typescript gets a bit icky with the way the Schemas are structured.
  const schema = await $RefParser.dereference(schemaPath);
  // extends is deprecated, and the data was inlined by RefParser.dereference into the allOf
  // it's still in the Schema for backwards compatibility, although its not really valid per JSON Schema Spec.
  delete (schema as any).extends;

  // Jixxed's Schema uses inheritance and defines the `event` field to be just any string
  // We can do better by making the events essentially be tagged unions.
  // We define the event field to be a literal, so one can just e.g.
  // obj.event === "Loadout" and TS knows we have a Loadout event using the Loadout structure
  const name = basename(schemaPath, ".json");
  const allOfIds = (schema.allOf ?? []).findIndex(
    (e) => (e as any).title === "Event",
  );
  if (allOfIds >= 0) {
    (schema as any).allOf[allOfIds].properties.event.const = name;
    delete (schema as any).allOf[allOfIds].properties.event.examples;
    delete (schema as any).allOf[allOfIds].properties.event.type;
  }
  const result =
    (
      await compile(schema as any, `${name}Event`, {
        format: true,
      })
    ).replaceAll("export ", "") + `\n\nexport default ${name}Event;`;
  await writeFile(join(generatedRoot, `${name}.ts`), result);

  injectBigint(schema);
  const resultBigInt =
    (
      await compile(schema as any, `${name}Event_BI`, {
        format: true,
      })
    ).replaceAll("export ", "") + `\n\nexport default ${name}Event_BI;`;
  await writeFile(join(generatedRoot, `${name}.bi.ts`), resultBigInt);

  mainIndexFile.push(`import ${name}Event from './${name}.js'`);
  mainIndexFile.push(`import ${name}Event_BI from './${name}.bi.js'`);
  simpleEventsFile.push(
    `export {type default as ${name}Event} from './${name}.js'`,
  );
  biEventsFile.push(
    `export {type default as ${name}Event_BI} from './${name}.bi.js'`,
  );
  eventNames.push(name + "Event");
}

// at the end, create a barrel file
mainIndexFile.push(
  `export type JournalEvent = `,
  ...eventNames.map((e) => `| ${e}`),
  `export type JournalEvent_BI = `,
  ...eventNames.map((e) => `| ${e}_BI`),
);

await writeFile(join(generatedRoot, "index.ts"), mainIndexFile.join("\n"));
await writeFile(join(generatedRoot, "events.bi.ts"), biEventsFile.join("\n"));
await writeFile(join(generatedRoot, "events.ts"), simpleEventsFile.join("\n"));
